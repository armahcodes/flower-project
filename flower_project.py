# -*- coding: utf-8 -*-
"""Flower_Project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/gist/joshuaarmah/b863a06431d87d2625fa675f0e2c54ec/flower_project.ipynb

# Flower Project - Supervised Learning
## By Joshua Armah
"""



# Commented out IPython magic to ensure Python compatibility.
#import the dependicies 
# %matplotlib inline
import numpy as np
import matplotlib.pyplot as plt
import seaborn; 
import sklearn as sk
from sklearn import neighbors, datasets
from sklearn.linear_model import LinearRegression
from scipy import stats
import pylab as pl
from matplotlib.colors import ListedColormap

# import
pl.rcParams['figure.figsize'] = (10, 7)
seaborn.set()

"""## Dataset"""

# import some data to play with
iris = datasets.load_iris()

# dataset description
print(iris.DESCR)

## Explore the data

from sklearn.datasets import load_iris
iris = load_iris()

n_samples, n_features = iris.data.shape

test_data = iris.data + np.random.rand(n_samples, n_features)
test_target = iris.target

# print(iris.keys())
print('Dataset shape is', iris.data.shape)
print('The dataset has', n_samples, 'records of IRIS members.')
print('Each record has', n_features, 'features.')
print('The features are', iris.feature_names)
print('The dataset has', iris.target.shape, ' records of IRIS groups.')
print('The IRIS group names are', iris.target_names)
np.bincount(iris.target)
# maximum values
iris.data.max(axis=0)
# minimum values
iris.data.min(axis=0)
# mean values
iris.data.mean(axis=0)

#Format labels to color bar with Target Names
formatter = plt.FuncFormatter(lambda i, *args: iris.target_names[int(i)])

def plot2features(x_index, y_index):

    plt.scatter(iris.data[:, x_index], iris.data[:, y_index],
                c=iris.target, cmap=plt.cm.get_cmap('RdYlBu', 3))
    plt.colorbar(ticks=[0, 1, 2], format=formatter)
    plt.clim(-0.5, 2.5)
    plt.xlabel(iris.feature_names[x_index])
    plt.ylabel(iris.feature_names[y_index]);
    
plot2features(0, 1)

"""## Build the model"""

X_new = [2.5, 3, 1, 1]
def predict_new(clf, X_pred=X_new):
    
    result = clf.predict([X_pred, ])

    print('The new is a', iris.target_names[result])
    print(iris.target_names)
    print(clf.predict_proba([X_pred, ]))

X = iris.data
y = iris.target
h = .02
# Build The Model
knn = neighbors.KNeighborsClassifier(n_neighbors=3, weights='uniform')



"""## Train the model"""

# Use Library to split data
from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y)
X_train.shape, X_test.shape

# fit the model
knn.fit(X_train, y_train)

"""## Evaluate model"""

y_pred = knn.predict(X_test)
print("{0} / {1} correct".format(np.sum(y_test == y_pred), len(y_test)))

from sklearn.metrics import accuracy_score
accuracy_score(y_test, y_pred)

knn.score(X_test, y_test)

